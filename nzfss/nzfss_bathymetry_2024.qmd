---
title: Morphometric distribution of depth and basin shape in Aotearoa New Zealand lakes
subtitle: Using machine learning to improve national lake depth predictions
format: 
  revealjs:
    theme: dark
    logo: www/limnotrack_border.jpg
    title-slide-attributes:
      data-state: "hide-menubar"
    footer: ""
    toc: false
    # template-partials:
    #   - title-slide.html
    transition: slide
    background-transition: fade
    controls: true
    controls-layout: bottom-right
    chalkboard: false
    menu: false
    view-distance: 100
    simplemenu:
        flat: true
        barhtml:
            header: "<div class='menubar'><ul class='menu'></ul><div>"
        scale: 0.2
revealjs-plugins:
    - simplemenu
author:
  - name: Tadhg Moore, Chris McBride, Deniz Özkundakci, Mathew Allen, Moritz K Lehmann, Matthew J Prentice, Whitney Woelmer, Maggie Armstrong, Kevin Rose
    # affiliation: Limnotrack, The University of Waikato, Waikato Regional Council, Starboard Maritime Intelligence, Rensselaer Polytechnic Institute
    # orcid: 0000-0002-3834-8868
    # email:
  #   affiliation: Limnotrack
  #   # orcid: 0000-0002-3834-8868
  #   # email: tadhg@limnotrack.com
  # - name: Chris McBride
  #   affiliation: Limnotrack
  # - name: Deniz Özkundakci
  #   affiliation: The University of Waikato
  # - name: Mathew Allen
  #   affiliation: Waikato Regional Council
  # - name: Moritz K Lehmann
  #   affiliation: Starboard Maritime Intelligence
  # - name: Matthew J Prentice
  #   affiliation: The University of Waikato
  # - name: Whitney Woelmer
  #   affiliation: The University of Waikato
  # - name: Maggie Armstrong
  #   affiliation: The University of Waikato
  # - name: Kevin Rose
  #   affiliation: Rensselaer Polytechnic Institute
editor: visual
editor_options: 
  chunk_output_type: console
bibliography: references.bib
date: "2024-11-19"
css: style.css
---

```{r}
#| label: setup

library(sf)
fenz_depths <- readRDS("data/fenz_depths.rds") |> 
  dplyr::filter(!is.na(z_max), !is.na(GeomorphicType))
n_fenz <- nrow(fenz_depths)

lernz_depths <- read.csv("data/lernz_depths.csv")
lyr <- readRDS("data/lyr.rds")
id_names <- lyr |> 
  sf::st_drop_geometry() |>
  dplyr::select(id_final, name_final)

gm_type <- lyr |> 
  sf::st_drop_geometry() |> 
  dplyr::select(id_final, GeomorphicType) 

lake_summ <- read.csv("data/lake_bathy_summary.csv") |> 
  dplyr::left_join(gm_type, by = c("id_final" = "id_final"))

library(ggplot2)
library(plotly)


# Set geomorphology colours
geomorph_class <- unique(fenz_depths$GeomorphicType)
geomorph_class <- geomorph_class[!is.na(geomorph_class)]
geomorph_class <- c(geomorph_class, "Unknown")
geomorph_cols <- RColorBrewer::brewer.pal(length(geomorph_class), "Set3")
names(geomorph_cols) <- geomorph_class

# Set source colours
source_cols <- c("FENZ" = "#8DA0CB", "Hydrolakes" = "#FC8D62", 
                 "GloBATHY" = "#A6D854", "ML model" = "black")
sc_df <- data.frame(source = names(source_cols), col = source_cols)

```



## Motivation {.smaller data-name="Background"}

-   Developing the Lake Ecosystem Research New Zealand modelling platfom (LERNZmp). ![](www/lernzmp_logo.png){width="105"}
-   Lake depth and morphometry are key drivers of lake ecosystem function [@ganz2024], therefore accurate depth data is essential.
-   The Freshwater Ecosystems New Zealand (FENZ) database is the most comprehensive database of lake morphometry in New Zealand, but is limited in its depth data.
-   NZ lakes provide a unique opportunity to develop a comprehensive database of lake depth and morphometry, particularly given the diversity of lake size, depth and geomorphic type.

## Objectives {.unnumbered .unlisted}

-   Develop a comprehensive database of lake depth and morphometry for New Zealand.
-   Use machine learning to predict mean and maximum lake depth from this data.
-   Compare these predictions to the FENZ database and other global lake depth databases e.g. maximum lake depths - GLOBathy[@khazaei2022] and mean lake depth - HydroLAKES [@messager2016]

## {.smaller}

::::: columns
::: {.column width="50%"}
-   Lack of a central database on lake morphometry, particularly depth
-   Large number of bathymetric data has been recorded across lakes in New Zealand
-   Current predictions of max lake depth, within the FENZ database (n=`r n_fenz`) are limited and have clear biases
:::

::: {.column width="50%"}
```{r}
#| label: fig-fenz-depth-distribution
#| fig.cap: "Depth distribution of FENZ lakes. The x-axis is log10 scaled."
#| fig.width: 6
#| fig.height: 4

labs <- fenz_depths |> 
  sf::st_drop_geometry() |> 
  dplyr::group_by(GeomorphicType) |>
  dplyr::summarise(n = dplyr::n()) |>
  dplyr::mutate(label = paste0(GeomorphicType, " (n=", n, ")"))

df <- fenz_depths |> 
  sf::st_drop_geometry() |> 
  dplyr::left_join(labs, by = "GeomorphicType")


plot_ly() |>
  add_histogram(data = df, x = ~log10(z_max), color = ~GeomorphicType,
                colors = geomorph_cols, opacity = 1,
                marker = list(line = list(color = "black", width = 1))) |>
  layout(
    xaxis = list(title = "log10(Depth)"),
    yaxis = list(title = "Frequency"),
    # legend = list(orientation = "h", x = 0.2, y = -0.2),
    barmode = "stack"#,
    # updatemenus = list(
    #   list(
    #     type = "buttons",  # Using buttons to control color visibility
    #     x = 0.1,  # Positioning of the button
    #     y = 1.05,  # Positioning of the button
    #     buttons = list(
    #       list(
    #         label = "Fill Color On",
    #         method = "restyle",
    #         args = list("opacity", 1)  # Set fill color on by controlling opacity
    #       ),
    #       list(
    #         label = "Fill Color Off",
    #         method = "restyle",
    #         args = list("opacity", 0.5)  # Set fill color off by controlling opacity
    #       )
    #     )
    #   )
    # )
  )




  # ggplot() +
#   geom_point(data = df, aes(x = area_Ha, y = z_max, colour = GeomorphicType),
#              alpha = 0.5, size = 1) +
#   scale_y_log10(breaks = c(1, 5, 10, 20, 50, 100, 400)) +
#   scale_x_log10(breaks = c(1, 5, 10, 50, 100, 1000)) +
#   labs(x = "Area (ha)", y = "Depth (m)")+
#   theme_bw(base_size = 16)

  # ggplot() +
#   geom_histogram(data = df, aes(x = z_max),
#                  bins = 30, colour = "white") +
#   facet_wrap(~label, scales = "free_y") +
#   scale_x_log10(breaks = c(1, 5, 10, 50, 100, 400)) +
#   labs(y = "Count", x = "Depth (m)")+
#   theme_bw(base_size = 14) 

# library(plotly)
# plot_ly() |> 
#   add_histogram(data = fenz_depths, x = ~z_max, nbins = 50) |>
#   layout(xaxis = list(title = "Depth (m)", type = "log"),
#          yaxis = list(title = "Frequency"))
# add_markers(data = fenz_depths, x = ~area_Ha, y = ~z_max,
#             opacity = 0.3) |> 
# layout(xaxis = list(type = "log", title = "Area (ha)"),
#        yaxis = list(type = "log", title = "Depth (m)"))

```

:::
:::::

## Max depth vs Lake area {.unnumbered .unlisted}

```{r}
#| label: fig-fenz-depth-area
#| fig.cap: "Depth vs Area of FENZ lakes"

ggplot() +
  geom_point(data = fenz_depths, aes(x = area_Ha, y = z_max),
             alpha = 0.2, size = 1) +
  scale_y_log10(breaks = c(1, 5, 10, 20, 50, 100, 400)) +
  scale_x_log10(breaks = c(1, 5, 10, 50, 100, 1000)) +
  labs(x = "Area (ha)", y = "Depth (m)")+
  theme_bw(base_size = 16) 

```

## Lakes with bathymetry data {.smaller .unnumbered .unlisted}

::::: columns
::: {.column width="50%"}
-   Lakes with bathymetric data are relatively evenly distributed across New Zealand.
-   Lake geomorphic type is highly regionalised.
:::
::: {.column width="50%"}

```{r}
#| label: fig-fenz-map
#| fig.cap: "Map of lakes with bathymetric data and maximum depth data in New Zealand. Lakes with bathymetry data have a black marker."
#| fig.width: 3.75
#| fig.height: 5
library(tmap)
bmap <- paste0("https://basemaps.linz.govt.nz/v1/tiles/aerial/WebMercatorQuad/{z}/{x}/{y}.webp?api=", 
               Sys.getenv("LINZ_BASEMAP_KEY"))
tmap_options(basemaps = "https://basemaps.linz.govt.nz/v1/tiles/aerial/WebMercatorQuad/{z}/{x}/{y}.webp?api=c01hsah0ttthgq51dgrqbw9r2bd", check.and.fix = TRUE)
nz_region_clip <- readRDS("data/nz_region_clip.rds")
# tmap_mode("view")
# tm_shape(nz_region_clip, name = "Region") +
#   tm_borders(col = "black", lwd = 2)
# 
tmap_mode("plot")

depth_lakes <- lyr |> 
  dplyr::filter(id_final %in% lernz_depths$id_final, !is.na(max_depth)) |> 
  sf::st_point_on_surface()
bathy_lakes <- depth_lakes |> 
  dplyr::filter(bathy)

tm_shape(nz_region_clip, name = "Region") +
  tm_fill(col = "legend_name", title = "Region", alpha = 0.8, legend.show = F) +
  tm_layout(legend.position = c("left", "top")) +
  tm_shape(depth_lakes, name = "Lake marker") +
  tm_symbols(col = "GeomorphicType", size = 0.3, title.col = "Geomorphic type",
             palette = geomorph_cols) +
  tm_shape(bathy_lakes, name = "Bathy lakes") +
  tm_symbols(col = "black", size = 0.05) +
  tm_compass(position = c("right", "top")) +
  tm_scale_bar(text.size = 0.6, position = c("right", "bottom")) 

```

:::
:::::

## Methods {.smaller data-name="Methods"}

-   Bathymetry survey data were sourced from a variety of sources - paper maps, digital files, and online databases (n=.
-   Shoreline data were updated using satellite and aerial imagery.
-   Depth data were interpolated using a Multilevel B-Spline Approximation (MBA) algorithm.
-   Hypsographic curves were calculated for each lake.
-   Comparison of depth and area with other databases.
-   Used machine learning to predict lake depth from morphometric data for all lakes in New Zealand and benchmark against the FENZ dataset.


## Depth-area relationship {.smaller data-name="Results" .unnumbered .unlisted}

```{r}
#| label: fig-depth-area-latitude
#| fig-cap: Summary of measured lake area and max depth by latitude and elevation.

df <- lake_summ |> 
  dplyr::rename(Area = area_Ha, Depth = z_max, Elevation = elevation, 
                Latitude = lat, `Geomorphic type` = GeomorphicType) |>
  # Round all numeric to 2 digits
  dplyr::mutate_if(is.numeric, ~round(., 2))

p <- ggplot() +
  geom_point(data = df, aes(x = Area, y = Depth, color = Latitude,
                                   size = Elevation)) +
  # scale_colour_fermenter(palette = "RdYlBu") +
  scale_color_viridis_c() +
  scale_size_binned(breaks = c(0, 250, 500, 750, 1000, 2000)) +
  scale_y_log10(breaks = c(1, 5, 10, 20, 50, 100, 400)) +
  scale_x_log10(breaks = c(1, 5, 10, 50, 100, 1000, 10000)) +
  # annotation_logticks() +
  labs(x = "Area (ha)", y = "Depth (m)", color = "Latitude", 
       size = "Elevation\n(masl)")+
  theme_bw(base_size = 16)
# p

ggplotly(p, height = 500, width = 700)

```

## Depth-area x geomorphic type  {.smaller .unnumbered .unlisted}

```{r}
#| label: fig-depth-area-gmtypew
#| fig-cap: Summary of measured lake area and max depth by geomorphic type.

p <- ggplot() +
  geom_point(data = df, aes(x = Area, y = Depth, color = `Geomorphic type`)) +
  geom_smooth(data = df, aes(x = Area, y = Depth, color = `Geomorphic type`),
              method = "lm", se = FALSE) +
  scale_color_manual(values = geomorph_cols) +
  scale_y_log10(breaks = c(1, 5, 10, 20, 50, 100, 400)) +
  scale_x_log10(breaks = c(1, 5, 10, 50, 100, 1000)) +
  labs(x = "Area (ha)", y = "Depth (m)", color = "Geomorphic\ntype")+
  theme_bw(base_size = 14)
# p
ggplotly(p, height = 500, width = 700)

```


## Predicting mean and max depth {.smaller .unnumbered .unlisted}

:::::: panel-tabset
### Max depth

::::: columns
::: {.column width="60%"}

```{css}
#| echo: false

.reveal table {
  font-size: smaller;
}

```

```{r}
#| label: fig-max-depth
#| fig.cap: "Predicted vs observed max depth. Note that the x and y axes are log10 scaled."

comp_max_depth <- read.csv("data/comp_max_depth.csv") |> 
  dplyr::filter(source != "Hydrolakes") |> 
  dplyr::mutate(
    source = dplyr::case_when(
      source == "Model" ~ "ML model",
      .default = source
    ),
    label = dplyr::case_when(
      source == "ML model" ~ gsub("Model", "ML model", source),
      .default = source
    )
  ) |> 
  dplyr::rename(`Measured depth` = z_max, `Predicted depth` = LERNZmp) |> 
  dplyr::left_join(id_names, by = c("id_final" = "id_final"))
comp_mean_depth <- read.csv("data/comp_mean_depth.csv") |> 
  dplyr::filter(source != "GloBATHY") |> 
    dplyr::mutate(
    source = dplyr::case_when(
      source == "Model" ~ "ML model",
      .default = source
    )
  ) 


cols <- comp_max_depth |> 
  dplyr::select(source, label) |> 
  dplyr::distinct() |> 
  dplyr::left_join(sc_df, by = "source") 
cols_vec <- cols$col
names(cols_vec) <- cols$label

lims <- range(comp_max_depth$`Predicted depth`, comp_max_depth$`Measured depth`,
              # comp_mean_depth$z_mean, comp_mean_depth$LERNZmp,
              na.rm = TRUE)
brks <- c(1, 10, 100)

p <- ggplot() +
  geom_point(data = comp_max_depth, aes(x = `Measured depth`, y = `Predicted depth`, color = label)) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  scale_x_log10(breaks = brks) +
  scale_y_log10(breaks = brks) +
  scale_color_manual(values = cols_vec) +
  labs(x = "Measured max depth (m)", y = "Predicted max depth (m)", color = "Source") +
  coord_equal() +
  theme_bw(base_size = 14)
# p
ggplotly(p, height = 500, width = 600)


# plot_ly() |> 
#   add_trace(data = comp_max_depth, x = ~`Measured depth`,
#             y = ~`Predicted depth`, colors = cols_vec,
#             hoverinfo = "text",
#             text = paste0("Lake: ", comp_max_depth$name_final, "<br>",
#                                "Predicted depth: ", round(comp_max_depth$`Predicted depth`, 1), "<br>",
#                                "Measured depth: ", round(comp_max_depth$`Measured depth`, 1), "<br>",
#                                "Source: ", comp_max_depth$label),
#             type = "scatter", mode = "markers", color = ~label) |> 
#   add_trace(x = lims, y = lims, type = "scatter", mode = "lines", name = "1:1 line",
#             showlegend = TRUE, line = list(color = "grey")) |> 
#   layout(xaxis = list(title = "Measured max depth (m)", type = "log", range = log10(lims)),
#          yaxis = list(title = "Predicted max depth (m)", type = "log", range = log10(lims)),
#          legend = list(orientation = "h", x = 0.2, y = -0.2)) |> 
#   layout(width = 600, height = 600)


```

:::

::: {.column width="40%"}
```{r}
#| label: tbl-max-depth
#| tbl.cap: "Model fit for max depth"

tbl <- comp_max_depth |> 
  dplyr::rename(z_max = `Measured depth`, LERNZmp = `Predicted depth`) |> 
  dplyr::filter(!is.na(LERNZmp)) |> 
  dplyr::mutate(diff = LERNZmp - z_max,
                prop_error = abs(diff) / z_max) |>
  dplyr::group_by(source) |>
  dplyr::summarise(bias = mean(diff, na.rm = TRUE),
                   mae = mean(abs(diff), na.rm = TRUE),
                   rmse = sqrt(mean(diff^2, na.rm = TRUE)),
                   r2 = ifelse(all(is.na(diff)), NA, cor(LERNZmp, z_max, use = "complete.obs")^2),
                   pe = mean(prop_error, na.rm = TRUE),
                   n = sum(!is.na(diff))
                   ) |>
  dplyr::mutate(source = factor(source, levels = c( "FENZ", "Hydrolakes", "GloBATHY", "ML model")),
                variable = "Lake max depth") |>
  dplyr::select(source, n, bias, rmse, r2) |>
  # Round all numeric to 2 digits
  dplyr::mutate_if(is.numeric, ~round(., 2)) |>
  dplyr::rename(R2 = r2, RMSE = rmse, Bias = bias, N = n, Source = source)

max_depth_r2 <- tbl |> 
  dplyr::filter(Source == "Model") |> 
  dplyr::pull(R2)

fenz_max_depth_r2 <- tbl |> 
  dplyr::filter(Source == "FENZ") |> 
  dplyr::pull(R2)

tbl |>
  knitr::kable(caption = "Model fit for max depth") 
```

:::
:::::

### Mean depth

::::: columns
::: {.column width="60%"}

```{r}
#| label: fig-mean-depth
#| fig.cap: "Predicted vs observed mean depth. Note that the x and y axes are log10 scaled."
#| fig.width: 4
#| fig.height: 4

comp_mean_depth <- read.csv("data/comp_mean_depth.csv") |> 
  dplyr::filter(source != "GloBATHY", !is.na(LERNZmp)) |> 
  dplyr::rename(`Measured depth` = z_mean, `Predicted depth` = LERNZmp) |> 
  dplyr::left_join(id_names, by = c("id_final" = "id_final"))

cols <- comp_mean_depth |> 
  dplyr::select(source, label) |> 
  dplyr::distinct() |> 
  dplyr::left_join(sc_df, by = "source") 
cols_vec <- cols$col
names(cols_vec) <- cols$label

lims <- range(comp_mean_depth$`Predicted depth`, comp_mean_depth$`Measured depth`,
              # comp_mean_depth$z_mean, comp_mean_depth$LERNZmp,
              na.rm = TRUE)
brks <- c(1, 10, 100)


plot_ly() |> 
  add_trace(data = comp_mean_depth, x = ~`Measured depth`,
            y = ~`Predicted depth`, colors = cols_vec,
            hoverinfo = "text",
            text = paste0("Lake: ", comp_mean_depth$name_final, "<br>",
                               "Predicted depth: ", round(comp_mean_depth$`Predicted depth`, 1), "<br>",
                               "Measured depth: ", round(comp_mean_depth$`Measured depth`, 1), "<br>",
                               "Source: ", comp_mean_depth$label),
            type = "scatter", mode = "markers", color = ~label) |> 
  add_trace(x = lims, y = lims, type = "scatter", mode = "lines", name = "1:1 line",
            showlegend = TRUE, line = list(color = "grey")) |> 
  layout(xaxis = list(title = "Measured mean depth (m)", type = "log", range = log10(lims)),
         yaxis = list(title = "Predicted mean depth (m)", type = "log", range = log10(lims)),
         legend = list(orientation = "h", x = 0.2, y = -0.2))


```

:::

::: {.column width="40%"}
```{r}
#| label: tbl-mean-depth
#| tbl.cap: "Model fit for mean depth"

tbl <- comp_mean_depth |> 
  dplyr::rename(z_mean = `Measured depth`, LERNZmp = `Predicted depth`) |> 
  dplyr::filter(!is.na(LERNZmp)) |> 
  dplyr::mutate(diff = LERNZmp - z_mean,
                prop_error = abs(diff) / z_mean) |>
  dplyr::group_by(source) |>
  dplyr::summarise(bias = mean(diff, na.rm = TRUE),
                   mae = mean(abs(diff), na.rm = TRUE),
                   rmse = sqrt(mean(diff^2, na.rm = TRUE)),
                   r2 = ifelse(all(is.na(diff)), NA, cor(LERNZmp, z_mean, use = "complete.obs")^2),
                   pe = mean(prop_error, na.rm = TRUE),
                   n = sum(!is.na(diff))
                   ) |>
  dplyr::mutate(source = factor(source, levels = c( "FENZ", "Hydrolakes", "GloBATHY", "Model")),
                variable = "Lake mean depth") |>
  dplyr::select(source, n, bias, rmse, r2) |>
  # Round all numeric to 2 digits
  dplyr::mutate_if(is.numeric, ~round(., 2)) |>
  dplyr::rename(R2 = r2, RMSE = rmse, Bias = bias, N = n, Source = source)

mean_depth_r2 <- tbl |> 
  dplyr::filter(Source == "Model") |> 
  dplyr::pull(R2)

fenz_mean_depth_r2 <- tbl |> 
  dplyr::filter(Source == "FENZ") |> 
  dplyr::pull(R2)

tbl |>
  knitr::kable(caption = "Model fit for mean depth") 
```

:::
:::::
::::::

## Distribution of volume development

Development of Volume, $D_V$ (Hutchinson 1957) is a measure of departure of the shape of the lake basin from that of a cone calculated using the maximum depth $Z_{max}$ and the average depth $\bar{Z}$ :

$$D_V = \frac{3 \times \bar{Z}}{Z_{max}}$$

For the majority of lakes, DV \>1 (i.e. a conical depression). DV is greatest in shallow lakes with flat bottoms.

## Machine learning {.r-fit-text .unnumbered .unlisted}

Bathymetric data from 156 lakes were digitised and collated for use in this study.

Using a machine learning model, we were able to predict maximum lake depth from morphometric data with an $r^2$ = `r max_depth_r2` and mean lake depth with an $r^2$ = `r mean_depth_r2`.

This was substantially better than the FENZ dataset, which had an $r^2$ = `r fenz_max_depth_r2` for max depth and `r fenz_mean_depth_r2` for mean depth.

## Applications {.smaller data-name="Conclusions"}

-   Predicted depth data is used in the LERNZmp for lakes without bathymetric data.
-   Highlights lakes with limited depth data for future surveying.
-   Provides a comprehensive database of lake depth and morphometry for Aotearoa New Zealand for future research.

## References {.unnumbered .unlisted}

::: {#refs}
:::
